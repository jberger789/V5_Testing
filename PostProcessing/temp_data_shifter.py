import dataset,datetime

SIDES = {"BLACK": 'BLK', "RED": 'RED'}

RESULTS_DB = dataset.connect('mysql://guest:password@localhost/test_results')
""":class:`Database <dataset.database>`: Database containing results from all tests."""
TEMPS_DB = dataset.connect('sqlite:///../Results/DAQTEMPS.db')
""":class:`Database <dataset.Database>`: Database containing temperature data collected during the test run."""

def insert_ignore_many_query(table, rows):
	"""Generate an appropriate string for inserting potentially duplicate rows into an SQL table.

	Parameters
	----------
	table : str
		The name of an SQL table in the current database.  
		Assumes a table with that name exists in :const:`RESULTS_DB`.
	rows : list of dict
		A list of rows to insert into ``table``.  
		Assumes every row dictionary contains corresponding 
		values for every data column in the table.

	Returns
	-------
	str
		A string representing an SQL statement that, if executed, performs an *INSERT IGNORE* of every row in ``rows`` into ``table``.

	"""
	return "INSERT IGNORE INTO {}(time_stamp,unit,side,ambient,outtake,intake) VALUES {};".format(table,rowvals4SQLmany(rows))

def rowvals4SQLquery(row):
	"""Generates a string representation of the values in ``row``, formatted for an SQL query.

	Parameters
	----------
	row : dict
		The dictionary representing the row.
		Assumes ``row`` contains corresponding values for every data column in the table

	Returns
	-------
	str
		A string containing comma separated values from ``row``, enclosed in parentheses

	"""
	return '('+','.join(f'"{row[col]}"' for col in row) + ')'

def rowvals4SQLmany(row_list):
	"""Generates a string representation of the values in many rows, formatted for an SQL query.

	Parameters
	----------
	row_list : list of dict
		A list containing the row dictionaries to be inserted. Assumes every row 
		dictionary contains corresponding values for every data column in the table.

	Returns
	--------
	str
		A string containing strings generated by :meth:`rowwvals4SQLquery` for each row in ``row_list``, separated by commas.

	"""
	return ','.join(rowvals4SQLquery(row) for row in row_list)

def temp_shifter():
	"""Shifts temperature data from :const:`TEMPS_DB` to :const:`RESULTS_DB`.

	Takes in temperature data from :const:`TEMPS_DB`, rounds their time stamps
	to the nearest ten seconds, formats them as rows split by side, and inserts
	the rows into the *TEMPERATURES* table in :const:`RESULTS_DB`

	Assumes:
		* Both databases exist as defined
		* The row in *TESTS* with the time interval containing the data to be shifted exists
		* The tables in both databases exist and are formatted as expected
	"""
	test_num = eval(input("Which test do you want to import temperature data for? "))
	test_row = RESULTS_DB['TESTS'].find_one(id=test_num)
	rows = TEMPS_DB.query('SELECT * FROM Temperature WHERE time>="{}" AND time<="{}";'.format(test_row['start_time'],test_row['end_time']))
	next_rows = []
	for r in rows:
		next_rows += convert_row(r)
	RESULTS_DB.query(insert_ignore_many_query('TEMPERATURES',next_rows))

def round_time(tm_str):
	"""Generates a :class:`datetime.datetime` object containing a rounded version of a time stamp string. 

	Parameters
	----------
	tm_str : str
		A string containing a representation of a :class:`datetime.datetime` object in standard format.
			
		Standard format is defined as ``"YYYY-MM-DD hh:mm:ss[:msecs]"``

	Returns
	--------
	:class:`datetime.datetime`
		A :class:`datetime.datetime` object, containing the timestamp from ``tm_str`` rounded to the nearest ten second mark

	"""
	rnd_tm = datetime.datetime.fromisoformat(tm_str)
	td = datetime.timedelta(seconds=round(rnd_tm.second/10+0.001)*10 - rnd_tm.second,microseconds=-rnd_tm.microsecond)
	return rnd_tm + td

def convert_row(row):
	"""Converts a row from :const:`TEMPS_DB` to two rows for :const:`RESULTS_DB`.

	Takes in a single row of temperature data from :const:`TEMPS_DB` and converts it 
	into two rows of temperature data to be inserted into *TEMPERATURES* in :const:`RESULTS_DB`.

	Parameters
	----------
	row : dict
		A dictionary representing the row retrieved from :const:`TEMPS_DB`.
		Assumes the row was retrieved successfully.

	Returns
	-------
	out_rows : list of dict
		A list containing the two newly generated rows.

	"""
	out_rows = []
	time_str = str(round_time(row['time']))
	for s in SIDES:
		next_row = {
		'time_stamp': time_str,
		'unit': 1,
		'side': SIDES[s],
		'ambient': row['AMBIENT'],
		'outtake': row[s+'_OUTTAKE'],
		'intake': row[s+'_INTAKE']
		}
		out_rows += [next_row]
	return out_rows

if __name__ == '__main__':
	temp_shifter()